package com.example.hiretop.viewModels

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.hiretop.R
import com.example.hiretop.app.HireTop.Companion.appContext
import com.example.hiretop.data.datastore.HireTopDataStoreRepos
import com.example.hiretop.helpers.FirebaseHelper
import com.example.hiretop.models.CandidateProfile
import com.example.hiretop.models.JobApplication
import com.example.hiretop.models.JobOffer
import com.example.hiretop.utils.Constant.CANDIDATES_COLLECTION_NAME
import com.example.hiretop.utils.Constant.JOB_APPLICATIONS_COLLECTION_NAME
import com.example.hiretop.utils.Constant.JOB_OFFERS_COLLECTION_NAME
import com.google.firebase.firestore.CollectionReference
import com.google.firebase.firestore.FieldValue
import com.google.firebase.firestore.FirebaseFirestore
import com.google.firebase.firestore.Query
import com.google.firebase.firestore.toObject
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.firstOrNull
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import kotlinx.coroutines.tasks.await
import java.io.InputStream
import javax.inject.Inject
import javax.inject.Named

@HiltViewModel
class CandidateViewModel @Inject constructor(
    private val db: FirebaseFirestore,
    @Named(JOB_OFFERS_COLLECTION_NAME)
    private val jobOffersCollection: CollectionReference,
    @Named(CANDIDATES_COLLECTION_NAME)
    private val candidateProfilesCollection: CollectionReference,
    @Named(JOB_APPLICATIONS_COLLECTION_NAME)
    private val jobApplicationsCollection: CollectionReference,
    appDataStore: HireTopDataStoreRepos,
    private val firebaseHelper: FirebaseHelper
) : ViewModel() {

    // Flow to hold the candidate profile id
    val candidateProfileId: Flow<String?> = appDataStore.candidateProfileId

    // StateFlow to hold the candidate profile
    private val _candidateProfile = MutableStateFlow<CandidateProfile?>(null)
    val candidateProfile: StateFlow<CandidateProfile?> = _candidateProfile

    // StateFlow to hold the recommended job offers
    private val _recommendedJobs = MutableStateFlow<List<JobOffer>?>(null)
    val recommendedJobs: StateFlow<List<JobOffer>?> = _recommendedJobs

    // StateFlow to hold the relevant job offers
    private val _jobOffers = MutableStateFlow<List<JobOffer>?>(null)
    val jobOffers: StateFlow<List<JobOffer>?> = _jobOffers

    private val _canApplyToJobOffer = MutableStateFlow<Boolean>(false)
    val canApplyToJobOffer: StateFlow<Boolean> = _canApplyToJobOffer

    /**
     * Function to fetch job offers based on candidate skills
     */
    fun getRecommendedJobs(candidateSkills: List<String>) {
        viewModelScope.launch(Dispatchers.IO) {
            jobOffersCollection
                .whereArrayContainsAny("skills", candidateSkills)
                .orderBy("postedAt", Query.Direction.DESCENDING)
                .limit(3)
                .get()
                .addOnSuccessListener { snapshot ->
                    val jobOffers = mutableListOf<JobOffer>()
                    for (document in snapshot.documents) {
                        val jobOffer = document.toObject(JobOffer::class.java)
                        jobOffer?.let {
                            jobOffers.add(it)
                        }
                    }
                    TODO("Handle success")
                }
                .addOnFailureListener {
                    TODO("Handle failure")
                }
        }
    }

    /**
     * Function to fetch relevant job offers based on candidate skills
     */
    fun getAllRelevantJobs(candidateSkills: List<String>) {
        viewModelScope.launch(Dispatchers.IO) {
            jobOffersCollection
                .whereArrayContainsAny("skills", candidateSkills)
                .orderBy("postedAt", Query.Direction.DESCENDING)
                .get()
                .addOnSuccessListener { snapshot ->
                    val mJobOffers = mutableListOf<JobOffer>()
                    for (document in snapshot.documents) {
                        val mJobOffer = document.toObject(JobOffer::class.java)
                        mJobOffer?.let {
                            mJobOffers.add(it)
                        }
                    }
                    _jobOffers.update { mJobOffers }
//                    callback(mJobOffers)
                }
                .addOnFailureListener {
                    TODO("Handle failure")
                }
        }
    }

    /**
     * Function to create a new candidate profile in Firestore
     * @param candidateProfile The candidate profile to be added
     * @param callback Callback to return the document ID generated by Firestore
     */
    fun createNewProfile(
        candidateProfile: CandidateProfile,
        onSuccess: () -> Unit,
        onFailure: (String) -> Unit
    ) {
        viewModelScope.launch(Dispatchers.IO) {
            candidateProfilesCollection
                .add(candidateProfile)
                .addOnSuccessListener { doc ->
                    _candidateProfile.update { currentValue ->
                        currentValue?.copy(profileId = doc.id)
                    }
                    onSuccess()
                }
                .addOnFailureListener {
                    onFailure(
                        it.message ?: it.localizedMessage
                        ?: appContext.getString(R.string.create_candidate_profile_failure_text)
                    )
                }
        }
    }

    /**
     * Function to add or update candidate profile
     */
    fun updateCandidateProfile(
        profileId: String,
        editedProfile: CandidateProfile,
        onSuccess: () -> Unit,
        onFailure: (String) -> Unit
    ) {
        viewModelScope.launch(Dispatchers.IO) {
            candidateProfilesCollection.document(profileId)
                .set(editedProfile)
                .addOnSuccessListener {
                    onSuccess()
                }
                .addOnFailureListener {
                    onFailure(
                        it.message
                            ?: appContext.getString(R.string.profile_update_failed_error_text)
                    )
                }
        }
    }

    /**
     * Function to get candidate profile by profile ID
     */
    fun getCandidateProfile(profileId: String, callback: (CandidateProfile?) -> Unit) {
        viewModelScope.launch(Dispatchers.IO) {
            candidateProfilesCollection.document(profileId)
                .get()
                .addOnSuccessListener { document ->
                    val profile = document.toObject<CandidateProfile>()
                    _candidateProfile.update { profile }
                    callback(profile)
                }
                .addOnFailureListener {
                    callback(null)
                    TODO("Handle failure")
                }
        }
    }

    fun uploadFileToFirebaseStorageAndGetUrl(inputStream: InputStream,
                                           fileName: String,
                                           onSuccess: (String) -> Unit,
                                           onFailure: (String) -> Unit) {
        viewModelScope.launch(Dispatchers.IO) {
            firebaseHelper.uploadFileToFirebaseStorage(
                inputStream, fileName, onSuccess, onFailure
            )
        }

    }

    /**
     * Function to add or edit banner image for candidate profile
     */
    fun addOrEditBannerImage(
        profileId: String,
        bannerUrl: String,
        onSuccess: () -> Unit,
        onFailure: (String) -> Unit
    ) {
        viewModelScope.launch(Dispatchers.IO) {
            candidateProfilesCollection.document(profileId)
                .update("bannerUrl", bannerUrl)
                .addOnSuccessListener {
                    onSuccess()
                }
                .addOnFailureListener {
                    onFailure(it.message ?: "Échec de mise à jour de la bannière")
                }
        }
    }

    /**
     * Function to add or edit profile picture for candidate profile
     */
    fun addOrEditProfilePicture(
        profileId: String,
        pictureUrl: String,
        onSuccess: () -> Unit,
        onFailure: (String) -> Unit
    ) {
        viewModelScope.launch(Dispatchers.IO) {
            candidateProfilesCollection.document(profileId)
                .update("pictureUrl", pictureUrl)
                .addOnSuccessListener {
                    onSuccess()
                }
                .addOnFailureListener {
                    onFailure(
                        it.message ?: it.localizedMessage
                        ?: "Échec de mise à jour de la photo de profil."
                    )
                }
        }
    }

    /**
     * Function to increment view count of job offer
     */
    fun incrementJobOfferViewCount(
        jobOfferId: String,
        onSuccess: () -> Unit,
        onFailure: (String) -> Unit
    ) {
        viewModelScope.launch(Dispatchers.IO) {
            jobOffersCollection.document(jobOfferId)
                .update("viewCount", FieldValue.increment(1))
                .addOnSuccessListener {
                    onSuccess()
                }
                .addOnFailureListener {
                    onFailure(it.message ?: "Échec d'incrémentation du nombre de vue.")
                }
        }
    }

    fun canApplyToJobOffer(jobOfferId: String, onFailure: (String) -> Unit) {
        viewModelScope.launch {
            val candidateId = candidateProfileId.firstOrNull()
            if (candidateId != null) {
                try {
                    val applicationQuery = jobApplicationsCollection
                        .whereEqualTo("candidateId", candidateId)
                        .whereEqualTo("jobOfferId", jobOfferId)
                        .limit(1)
                        .get().await()

                    _canApplyToJobOffer.update { applicationQuery.isEmpty }
                } catch (e: Exception) {
                    onFailure(e.message ?: "Impossible de vérifier l'état de la candidature.")
                }
            } else {
                onFailure("Profil du candidat introuvable.")
            }
        }
    }

    fun updateCanApplyToJobOffer(value: Boolean) {
        _canApplyToJobOffer.update { value }
    }

    fun applyToJobOffer(jobOffer: JobOffer, onSuccess: () -> Unit, onError: (String) -> Unit) {
        val jobApplication = JobApplication(
            candidateProfileId = candidateProfileId.toString(),
            jobOfferId = "${jobOffer.jobOfferID}",
            jobOfferTitle = jobOffer.title,
            companyName = jobOffer.company ?: "",
            location = jobOffer.location ?: "",
            locationType = jobOffer.locationType ?: "",
            status = "En attente", // Set initial status
            stages = "", // Set initial stages
            appliedAt = System.currentTimeMillis() // Set application timestamp
        )

        // Adding the job application to Firestore
        jobApplicationsCollection
            .add(jobApplication)
            .addOnSuccessListener {
                onSuccess.invoke()
            }
            .addOnFailureListener { exception ->
                onError.invoke(exception.message ?: "Failed to apply to the job offer")
            }
    }

}